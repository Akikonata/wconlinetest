(function(kity, window) {

    /**
     * @build
     */

    var exports = exports || window;

    var kc = {};

    kc.version = '1.0.1';

    kc.fx = true;

    exports.kc = kc;

    /**
     * @author techird
     *
     * @description
     * 工具方法，将一个数对齐到其所在的指定长度的整数区间端点上
     *
     * @param  {Number} value 要对齐的数字
     * @param  {Number} mod   区间的长度
     * @param  {Number} dir   对齐的端点类型，left - 对齐到区间左端，right - 对齐到区间右端。其他的取值会对齐到较近的一段。
     *
     * @return {Number}       对齐后的值
     *
     * @example
     *     kc.align(3.5, 2, 'left')   ==  2  // 命中的区间是 [2, 4]
     *     kc.align(3.5, 2, 'right')  ==  4  // 命中的区间是 [2, 4]
     *     kc.align(-5.5, 4, 'left')  == -8  // 命中的区间是 [-8, -4]
     *     kc.align(-5.5, 4, 'right') == -4  // 命中的区间是 [-8, -4]
     *     kc.align(6.7, 5)           ==  5  // 命中的区间是 [5, 10]
     *     kc.align(8.8, 5)           == 10  // 命中的区间是 [5, 10]
     */
    kc.align = function(value, mod, dir) {
        var left = value > 0 ?
            value - value % mod :
            value - value % mod - mod,
            right = left + mod;
        return dir == 'left' ? left :
            (dir == 'right' ? right : (
                value - left < right - value ? left : right));
    };

    /**
     * @author techird
     *
     * 对 v1 和 v2 对每个元素进行深度同步运算，返回运算的结果
     *
     * @param  {Object|Number} v1
     * @param  {Object|Number} v2
     * @param  {Function}      op 运算方法
     *
     * @return {Object|Number}
     *
     * @example
     *     var v1 = { a: 12, b: 14 },
     *         v2 = { a: 32, b: 66 };
     *     var v = kc.parallel( v1, v2, function(v1, v2) {
     *         return v1 + v2;
     *     } );
     *
     *     v.a == 44;
     *     v.b == 80;
     */
    kc.parallel = function parallel(v1, v2, op) {
        var value, n;

        if (v1 && v2 && typeof(v1) == 'object' && typeof(v2) == 'object') {
            value = {};
            for (n in v1) {
                if (v1.hasOwnProperty(n) && v2.hasOwnProperty(n)) {
                    value[n] = parallel(v1[n], v2[n], op);
                }
            }
            return value;
        }

        return op(v1, v2);
    };

    /**
     * @author techird
     *
     * 返回支持并行操作的方法
     *
     * @param  {Function} op 原始方法
     * @return {Function}    支持并行操作的方法
     */
    kc.parallelize = function(op) {
        return function(v1, v2) {
            return kc.parallel(v1, v2, op);
        };
    };

    var Query = kc.Query = kity.createClass('Query', (function() {

        function fieldMapper(field) {
            return function(x) {
                return x[field];
            };
        }

        function guessMapper(fn) {
            switch (typeof(fn)) {
                case 'string':
                    return fieldMapper(fn);
                case 'function':
                    return fn;
                default:
                    return function(x) {
                        return x;
                    };
            }
        }

        return {

            constructor: function(dataSet) {
                this.dataSet = dataSet;
            },

            where: function(condition) {
                var success = [],
                    data, i;
                for (i = 0; i < this.dataSet.length; i++) {
                    data = this.dataSet[i];
                    if (condition.call(data, data, i)) {
                        success.push(data);
                    }
                }
                return new Query(success);
            },

            count: function(condition) {
                if (condition) {
                    return this.where(condition).count();
                }
                return this.dataSet.length;
            },

            map: function(mapper) {
                var mapped = [],
                    data, i;
                mapper = guessMapper(mapper);
                for (i = 0; i < this.dataSet.length; i++) {
                    data = this.dataSet[i];
                    mapped.push(mapper.call(this, data, i));
                }

                return new Query(mapped);
            },

            max: function(mapper) {
                var maxData = null,
                    data, i, maxValue, value;

                mapper = guessMapper(mapper);

                for (i = 0; i < this.dataSet.length; i++) {
                    data = this.dataSet[i];
                    value = mapper.call(data, data, i);
                    if (maxData === null || value > maxValue) {
                        maxData = data;
                        maxValue = value;
                    }
                }

                return maxData;
            },

            min: function(mapper) {
                mapper = guessMapper(mapper);
                return this.max(function(data, i) {
                    return -mapper.call(data, data, i);
                });
            },

            sum: function(mapper) {
                var sum = 0,
                    data, i, value;

                mapper = guessMapper(mapper);

                for (i = 0; i < this.dataSet.length; i++) {
                    data = this.dataSet[i];
                    value = mapper.call(data, data, i);
                    sum += value;
                }

                return sum;
            },

            average: function() {
                return this.sum() / this.count();
            },

            list: function() {
                return this.dataSet;
            },

            groupBy: function(field) {
                var data = {},
                    tmp = {},
                    i, j, val,
                    dataSet = this.dataSet;

                var mapper = guessMapper(mapper);

                var arr = this.distinct(field),
                    f;

                for (i in arr) {
                    f = arr[i];
                    data[f] = [];

                    for (j = 0; j < dataSet.length; j++) {
                        if (f == dataSet[j][field]) {
                            val = mapper.call(dataSet[j], dataSet[j], field);
                            data[f].push(val);
                        }
                    }

                }

                return data;
            },

            distinct: function(field) {
                var tmp = {},
                    arr = [];
                for (i = 0; i < this.dataSet.length; i++) {
                    tmp[this.dataSet[i][field]] = 1;
                }

                for (i in tmp) {
                    arr.push(i);
                }

                return arr;
            },

            select: function(fields) {
                fields = typeof fields === 'string' ? [fields] : fields;

                var arr = [],
                    tmp = {},
                    i, j, field;

                for (i = 0; i < this.dataSet.length; i++) {

                    tmp = {};
                    for (j = 0; j < fields.length; j++) {
                        field = fields[j];
                        tmp[field] = this.dataSet[i][field]
                    }
                    arr.push(tmp);
                }

                return new Query(arr);
            }

        };

    })());

    var Ruler = kc.Ruler = kity.createClass('Ruler', {
        constructor: function(from, to) {
            this.ref_grid = [];
            this.map_grid = [];
            this.ref(from, to);
            this.map(from, to);
        },

        ref: function(from, to) {
            if (!arguments.length) return this._ref;
            this._ref = {
                from: +from,
                to: +to,
                dur: +to - +from
            };
            return this;
        },

        map: function(from, to) {
            if (!arguments.length) return this._map;
            this._map = {
                from: +from,
                to: +to,
                dur: +to - +from
            };
            return this;
        },

        reverse: function() {
            var ref = this._ref,
                map = this._map;
            return new Ruler(map.from, map.to).map(ref.from, ref.to);
        },

        measure: function(value) {
            // 强烈鄙视 JS 除零不报错，气死劳资了 —— techird
            if (this._ref.dur === 0) return 0;
            var ref = this._ref,
                map = this._map;

            return map.from + (value - ref.from) / ref.dur * map.dur;
        },

        grid: function(start, step, alignRef) {
            var ref = this._ref,
                map = this._map,
                ref_grid = [],
                map_grid = [],
                current;

            for (current = start; current < ref.to + step; current += step) {
                ref_grid.push(current);
            }

            this.ref_grid = ref_grid;

            if (alignRef) {
                this.ref(ref_grid[0], ref_grid[ref_grid.length - 1]);
            }

            for (var i = 0; i < ref_grid.length; i++) {
                map_grid.push(this.measure(ref_grid[i]));
            }

            this.map_grid = map_grid;

            return {
                ref: ref_grid,
                map: map_grid
            };
        },

        gridBySize: function(size) {
            var ref = this._ref;
            var start = kc.sugar.snap(ref.from, size, 'right');
            return this.grid(start, size);
        },

        // find a good mod
        fagm: function(count) {
            var dur = this._ref.dur,
                sdur = dur / count,
                adjust = 1;

            while (sdur > 100) {
                sdur /= 10;
                adjust *= 10;
            }

            while (sdur < 10) {
                sdur *= 10;
                adjust /= 10;
            }

            return (sdur | 0) * adjust;
        },

        align: function(value, mod, dir) {
            var left = value > 0 ?
                value - value % mod :
                value - value % mod - mod,
                right = left + mod;
            return dir == 'left' ? left :
                (dir == 'right' ? right : (
                    value - left < right - value ? left : right));
        },

        gridByCount: function(count, mod, alignRef, start) {
            mod = mod || this.fagm(count);
            var ref = this._ref;
            start = kity.Utils.isNumber(start) ? start : this.align(ref.from, mod, 'left');
            var size = mod;
            while (size * count < ref.dur) size += mod;
            return this.grid(start, size, alignRef);
        },

        gridByCategories: function(count) {
            var ref_grid = [],
                map_grid = [],
                i;
            for (i = 0; i < count; i++) {
                ref_grid.push(i);
            }

            this.ref_grid = ref_grid;

            for (i = 0; i < ref_grid.length; i++) {
                map_grid.push(this.measure(ref_grid[i]));
            }

            this.map_grid = map_grid;

            return {
                ref: ref_grid,
                map: map_grid
            };
        },

        checkOverflow: function(value) {
            if (value < this._ref.from) {
                return -1;
            }
            if (value > this._ref.to) {
                return 1;
            }
            return 0;
        },

        leanTo: function(num, type) {
            var grid = type == 'map' ? this.map_grid : this.ref_grid;
            if (!grid || grid.length == 0) return null;

            if (grid.length == 1) {
                return {
                    value: grid[0],
                    index: 0
                }
            }

            var first = grid[0];
            if (num < first) {
                return {
                    value: first,
                    index: 0
                }
            }

            var last = grid[grid.length - 1];
            if (num > last) {
                return {
                    value: last,
                    index: grid.length - 1
                }
            }

            var mod = grid[1] - grid[0];
            var result = this.align(num, mod);
            var index = Math.round(result / mod);

            return {
                value: result,
                index: index
            }
        }
    });

    Ruler.from = function(from) {
        return {
            to: function(to) {
                return new Ruler(from, to);
            }
        };
    };

    /**
     * @author techird
     *
     * 将坐标对齐至能绘制清晰的线条的位置
     *
     * @param  {Number|Point} p
     *         原始坐标位置（数字或点）
     * @return {Number|Point}
     *         修正后的坐标位置
     */
    kc.sharpen = function(p) {
        if (typeof(p) == 'number') return (p | 0) + 0.5;
        if ('x' in p && 'y' in p) return {
            x: (p.x | 0) + 0.5,
            y: (p.y | 0) + 0.5
        };
    };

    kc.Tools = {
        arraySum: function(arr) {
            var sum = 0;
            for (var i = 0; i < arr.length; i++) {
                sum += arr[i];
            }
            return sum;
        }
    };

    var ChartEvent = kc.ChartEvent = kity.createClass("ChartEvent", {
        constructor: function(target, kityEvent) {
            if (kityEvent) {
                this.kityEvent = kityEvent;
            }
            this.target = target;
        },

        getTargetChartElement: function() {
            var shape = this.kityEvent.targetShape;

            while (shape && !shape.host) {
                shape = shape.container;
            }

            return shape.host;
        }
    });

    var EventHandler = kc.EventHandler = kity.createClass('EventHandler', (function() {

        var DOMEvents = 'click dblclick mousedown contextmenu mouseup mouseout mouseover mouseenter mouseleave mousemove mousewheel touchstart touchmove touchend'.split(' ');

        function wrapCallback(callback, context) {
            return function(e) {
                callback.call(context, new kc.ChartEvent(context, e));
            };
        }

        return {

            constructor: function() {
                this._initEvents();
            },
            on: function(e, callback) {
                var _eventCallbacks = this._eventCallbacks;
                var eList = e.split(" ");
                for (var i = 0; i < eList.length; i++) {
                    var _arr = _eventCallbacks[eList[i]];
                    if (!_arr) {
                        _eventCallbacks[eList[i]] = [];
                    }
                    if (~DOMEvents.indexOf(eList[i]) && this.canvas) {
                        this.canvas.on(eList[i], wrapCallback(callback, this));
                    } else {
                        _eventCallbacks[eList[i]].push(callback);
                    }
                }
            },
            off: function(e, callback) {

            },
            trigger: function(e, p) {
                if (~DOMEvents.indexOf(e) && this.canvas) {
                    this.canvas.fire(e, p);
                } else {
                    this._fire(e, p);
                }
            },
            _fire: function(eve, p) {
                var me = this;
                var e;
                if (typeof eve === 'string') {
                    e = new kc.ChartEvent(me);
                    e.name = eve;
                } else {
                    e = eve;
                }
                e.data = p;
                var _callbacks = me._eventCallbacks[e.name];
                if (!_callbacks) {
                    return false;
                }
                for (var i = 0; i < _callbacks.length; i++) {
                    _callbacks[i].call(me, e);
                }
            },
            _initEvents: function() {
                this._eventCallbacks = {};
            },
            _resetEvents: function() {
                this._bindEvents();
            }
        };
    })());

    var Data = kc.Data = kity.createClass('Data', {

        mixins: [kc.EventHandler],

        constructor: function(origin) {
            this.origin = origin || {};
            this.callMixin();
        },

        format: function() {
            return this.origin;
        },

        /**
         * 更新指定路径的数据，会覆盖或新增到当前的数据中，并且触发 update 事件
         *
         * @param  {plain} delta  要更新的路径
         *
         * @example
         *
         * data.update({
         *     female: {
         *         value: 10,
         *         color: 'blue'
         *     },
         *     male: {
         *         value: 13,
         *         color: 'red'
         *     }
         * });
         *
         */
        update: function(delta) {
            this.origin = kity.Utils.extend(this.origin, delta);
            this.trigger('update');
        },

        clear: function() {
            this.origin = {};
            this.trigger('update');
        },
        reset: function(data) {
            this.origin = data;
        }
        // getStandard: function () {
        //     return this.format( this.origin );
        // }
    });

    function getCamelName(name) {
        return name.replace(/_(\w)/ig, function(match) {
            return match[1].toUpperCase();
        });
    }

    var elementUUID = 0;

    var ChartElement = kc.ChartElement = kity.createClass('ChartElement', {
        mixins: [kc.EventHandler],

        constructor: function(param) {

            this.canvas = new kity.Group();
            this.canvas.host = this;

            this.visible = true;

            this.param = param || {};
            //挂载数据在图形上，交互的时候通过container获取
            this._bindData();

            this.elements = {};

            this.callMixin();
        },

        addElement: function(key, chartElement) {
            if (arguments.length === 1) {
                chartElement = key;
                key = 'ChartElement_' + elementUUID++;
            }

            this.elements[key] = chartElement;
            this.canvas.addShape(chartElement.canvas);
            chartElement.container = this;
            return chartElement;
        },

        getElement: function(key) {
            return this.elements[key] || null;
        },

        removeElement: function(key) {
            var chartElement = this.elements[key];
            if (chartElement) {
                delete chartElement.container;
                this.canvas.removeShape(chartElement.canvas);
                delete this.elements[key];
            } else if (key === undefined) {
                for (var k in this.elements) {
                    chartElement = this.elements[k];
                    delete chartElement.container;
                    this.canvas.removeShape(chartElement.canvas);
                    delete this.elements[k];
                }
            }
        },

        setVisible: function(value) {
            if (value !== undefined) {
                this.visible = value;
                this.canvas.setStyle({
                    display: value ? 'inline' : 'none'
                });
            }
            return this;
        },

        isVisible: function() {
            return this.visible;
        },

        setPosition: function(x, y) {
            if ((typeof(x) == 'object') && ('x' in x) && ('y' in x)) {
                y = x.y || 0;
                x = x.x || 0;
            }
            x = x || 0;
            y = y || 0;
            var dx = x - (this.x || 0),
                dy = y - (this.y || 0);
            this.x = x;
            this.y = y;
            this.canvas.translate(dx, dy);
        },

        getPosition: function() {
            return {
                x: this.param.x || 0,
                y: this.param.y || 0
            };
        },

        // 兴趣点表示这个元素的关键位置
        getInterestPoint: function() {
            return this.getPosition();
        },

        registerUpdateRules: function() {
            return {
                'setPosition': ['x', 'y'],
                'setOpacity': ['opacity'],
                'setVisible': ['visible']
            };
        },

        updateByRule: function(method, methodParams, param, animatedBeginValueCopy, progress) {
            var shouldCall, lastParam, i, k;
            lastParam = this.param;


            for (i = 0; i < methodParams.length; i++) {
                k = methodParams[i];
                // 值没有改变的话，不更新
                if (k in param && (!this._firstUpdate || lastParam[k] !== param[k])) { //用!=符号， "" == 0为true
                    shouldCall = true;
                    break;
                }
            }

            if (shouldCall) {
                var currentParam = methodParams.map(function(name) {
                    return name in param ? param[name] : lastParam[name];
                });

                currentParam = currentParam.concat([animatedBeginValueCopy, progress]);
                this[method].apply(this, currentParam);
            }
        },

        update: function(param, animatedBeginValueCopy, progress) {

            var key, rules, method, params, i, shouldCall, updated;

            // 挂载数据在图形上
            this._bindData();

            // 没有被更新过，需要把所有参数都更新一遍，达到初始效果
            if (!this._updateRules) {
                this._updateRules = this.registerUpdateRules();
                param = kity.Utils.extend(this.param, param);
            }

            rules = this._updateRules;

            if (!param) {
                param = this.param;
            }

            updated = [];
            // 从更新规则中更新
            for (method in rules) {
                this.updateByRule(method, rules[method], param, animatedBeginValueCopy, progress);
                updated = updated.concat(rules[method]);
            }


            if (param && param != this.param) {

                kity.Utils.extend(this.param, param);

            }

            // 更新子元素
            for (key in param) {
                if (!~updated.indexOf(key) && this.elements[key]) {
                    this.elements[key].update(param[key]);
                }
            }

            this._firstUpdate = this._firstUpdate || +new Date();
            this.trigger('update');
            return this;
        },

        getBoundaryBox: function() {
            return this.canvas.getBoundaryBox();
        },

        getSize: function() {
            var box = this.getBoundaryBox();
            return {
                width: box.width,
                height: box.height
            };
        },

        flipX: function() {
            this.canvas.scale(-1, 1);
        },

        flipY: function() {
            this.canvas.scale(1, -1);
        },

        getParam: function(k) {
            return this.param[k];
        },

        setParam: function(k, v) {
            this.param[k] = v;
        },

        setOpacity: function(opacity) {
            this.canvas.setOpacity(opacity);
        },

        _bindData: function() {
            if (this.param.bind !== undefined) {
                this.canvas.bind = this.param.bind;
            }
        },

        setBindData: function(val) {
            this.canvas.bind = val;
        },

        getBindData: function() {
            return this.canvas.bind;
        },

        getPaper: function() {
            var tmp = this.canvas;
            while (tmp && tmp.container) {
                tmp = tmp.container;
                if (tmp instanceof kity.Paper) {
                    break;
                }
            }
            return tmp;
        }
    });

    (function(kc, kity) {

        kc.AnimatedChartElement = kity.createClass("AnimatedChartElement", {
            base: kc.ChartElement,

            getAnimatedParam: function() {
                throw new Error('请实现接口: getAnimatedParam()');
            },

            fxEnabled: function() {
                return kc.fx && this.param.fx != 'off';
            },

            stop: function() {
                if (this.timeline) {
                    this.timeline.stop();
                }
                return this;
            },

            animate: function(afterAnimated, duration, easing, callback) {
                if (!this.fxEnabled()) {
                    return this.update(afterAnimated);
                }

                var canAnimated = this.getAnimatedParam(),
                    beforeAnimated = this.param,
                    beforeAnimatedCopy = kity.Utils.copy(beforeAnimated),
                    beginParam = {},
                    finishParam = {},
                    staticParam = {},
                    animator;
                canAnimated.push('x');
                canAnimated.push('y');

                for (var p in afterAnimated) {
                    if (p in beforeAnimated && ~canAnimated.indexOf(p)) {
                        beginParam[p] = beforeAnimated[p];
                        finishParam[p] = afterAnimated[p];
                    } else {
                        staticParam[p] = afterAnimated[p];
                    }
                }

                this.update(staticParam);

                animator = new kity.Animator({
                    beginValue: beginParam,
                    finishValue: finishParam,
                    setter: function(target, param, timeline) {
                        var progress = timeline.getValueProportion();
                        if (progress > 1) progress = 1;
                        target.update(param, beforeAnimatedCopy, progress);
                    }
                });

                if (this.timeline) this.timeline.stop();

                this.timeline = animator.start(this,
                    duration || this.param.fxTiming || this.fxTiming || 500,
                    easing || this.param.fxEasing || this.fxEasing || 'ease',
                    callback);

                return this;
            }
        });

    })(kc, kity);

    var Chart = kc.Chart = kity.createClass('Chart', {
        base: kc.AnimatedChartElement,
        constructor: function(target, param) { //传入render目标
            this.callBase(param);
            this.setData({});

            if (typeof(target) == 'string') {
                target = document.getElementById(target);
            }
            target.setAttribute('onselectstart', 'return false');

            this.paper = new kity.Paper(target);
            this.paper.addShape(this.canvas);

            this.container = target;
            target.paper = this.paper;
        },
        getWidth: function() {
            return this.paper.getContainer().clientWidth;
        },
        getHeight: function() {
            return this.paper.getContainer().clientHeight;
        },
        setData: function(data) {
            if (this._dataBind) {
                this.data.off('update', this._dataBind);
            }
            this.data = data instanceof kc.Data ? data : new kc.Data(data);
            this.data.on('update', this._dataBind = (function() {
                this.update();
            }).bind(this));
        },
        getData: function() {
            return this.data;
        },
        update: function(param) {
            var data = this.data.format();
            this.callBase(param, data);
            if (this.updateChart) {
                this.updateChart(this.param, data);
            }
        }
    });

    var ConfigHandler = kc.ConfigHandler = kity.createClass('ConfigHandler', {

        constructor: function(config) {
            // this.config = config || {};
        },

        getConfig: function() {
            return this.config;
        },

        /*
         * path形式为"plotOptions.label.text", 即访问this.config.plotOptions.label.text
         */
        getOption: function(path) {
            return kity.Utils.queryPath(path, this.config);
        },

        /*
         * path同getOption参数path
         */
        setOption: function(path, value) {

            var arr = path.split('.');
            arr.unshift('config');
            var i = 1,
                p, cur, exp;

            while (i < arr.length) {
                cur = arr[i];
                p = getPath(i - 1, arr);
                if (!eval('"' + cur + '" in this.' + p)) {
                    exp = 'this.' + p + '.' + cur + ' = ' + (i == arr.length - 1 ? 'value' : '{}');
                    eval(exp);
                }

                i++
            }

            function getPath(index, arr) {
                var p = [];
                for (var i = 0; i <= index; i++) {
                    p.push(arr[i]);
                }
                return p.join('.');
            }


        }

    });

    // {
    //     points: [
    //         [0, 0],
    //         [100, 100],
    //         [100, 200]
    //     ],
    //     width: 1,
    //     color: 'black',
    //     dash: null
    // }
    var Polyline = kc.Polyline = kity.createClass("Polyline", {
        base: kc.AnimatedChartElement,
        constructor: function(param) {
            this.callBase(kity.Utils.extend({
                points: [
                    [0, 0],
                    [0, 0]
                ],
                width: 3,
                color: 'black',
                dash: null,
                animatedDir: 'y',
                factor: 0,
                close: false,
                fill: null
            }, param));

            this.polyline = new kity.Path();
            this.canvas.addShape(this.polyline);
        },

        getAnimatedParam: function() {
            return ['factor'];
        },

        registerUpdateRules: function() {
            return kity.Utils.extend(this.callBase(), {
                draw: ['points', 'factor', 'close', 'fill'],
                stroke: ['color', 'width', 'dash']
            });
        },

        parsePoint: function(index, pos, points) {
            if (points && points[index]) {
                return points[index][pos];
            } else {
                return 0;
            }
        },

        draw: function(points, factor, close, fill, animatedBeginValueCopy, progress) {
            var drawer = this.polyline.getDrawer(),
                s = kc.sharpen;

            if (points.length > 0) {
                drawer.clear();
                var dir = this.param.animatedDir,
                    xDir = (dir == undefined || dir == 'x'),
                    yDir = (dir == undefined || dir == 'y');


                if (animatedBeginValueCopy) {
                    var prevPoints = animatedBeginValueCopy.points;
                    var firstPointX = this.parsePoint(0, 0, prevPoints);
                    var firstPointY = this.parsePoint(0, 1, prevPoints);
                    var pointX, pointY;
                    drawer.moveTo(
                        xDir ? s((points[0][0] - firstPointX) * progress + firstPointX) : s(points[0][0]),
                        yDir ? s((points[0][1] - firstPointY) * progress + firstPointY) : s(points[0][1])
                    );

                    for (var i = 1; i < points.length; i++) {
                        if (xDir) pointX = this.parsePoint(i, 0, prevPoints);
                        if (yDir) pointY = this.parsePoint(i, 1, prevPoints);
                        drawer.lineTo(
                            xDir ? s((points[i][0] - pointX) * progress + pointX) : s(points[i][0]),
                            yDir ? s((points[i][1] - pointY) * progress + pointY) : s(points[i][1])
                        );
                    }

                } else {
                    drawer.moveTo(s(points[0][0]), s(points[0][1]));
                    for (var i = 1; i < points.length; i++) {
                        drawer.lineTo(s(points[i][0]), s(points[i][1]));
                    }
                }
                if (close) {
                    drawer.close();
                    this.polyline.fill(fill);
                }
            }
        },

        stroke: function(color, width, dash) {
            var pen = new kity.Pen();
            pen.setWidth(width);
            pen.setColor(color);
            if (dash) {
                pen.setDashArray(dash);
            }
            this.polyline.stroke(pen);
        }

    });

    var Bezier = kc.Bezier = kity.createClass("Bezier", {
        base: kc.ChartElement,
        constructor: function(param) {
            this.callBase(kity.Utils.extend({
                x1: 0,
                x2: 0,
                y1: 0,
                y2: 0,
                cx: 0,
                cy: 0,
                width: 1,
                color: 'black',
            }, param));
            var p = this.param;
            this.line = new kity.Path();
            this.canvas.addShape(this.line);
        },

        getAnimatedParam: function() {
            return ['x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'width'];
        },

        registerUpdateRules: function() {
            return kity.Utils.extend(this.callBase(), {
                draw: ['x1', 'y1', 'x2', 'y2', 'cx', 'cy'],
                stroke: ['color', 'width', 'dash']
            });
        },

        draw: function(x1, y1, x2, y2, cx, cy) {
            if (x1 && y1 && x2 && y2 && cx && cy) {
                this.line.getDrawer().clear().moveTo(x1, y1).bezierTo(cx, cy, cx, cy, x2, y2);
            }
        },

        stroke: function(color, width, dash) {
            var pen = new kity.Pen();
            pen.setWidth(width);
            pen.setColor(color);
            if (dash) {
                pen.setDashArray(dash);
            }
            this.line.stroke(pen);
        }
    });

    /**
     * 表示标签
     * @param {string} text
     *        标签的文本
     *
     * @param {string} at
     *        标签文本的位置，是指相对于标签本身坐标的方向
     *        允许取值为：center（默认）、left、right、up、down
     *
     * @param {int} margin
     *        文本离标签坐标在指定方向上的距离
     *
     * @param {Plain} style
     *        文本的样式（CSS）
     *
     * @param {int} color
     *        文本颜色
     */
    var Label = kc.Label = kity.createClass("Label", {

        base: kc.AnimatedChartElement,

        constructor: function(param) {
            this.callBase(kity.Utils.extend({
                text: '',
                at: 'center',
                margin: 0,
                style: {
                    family: 'Arial'
                },
                color: 'black',
                rotate: 0
            }, param));
            this.text = new kity.Text().setFont({
                'size': 12,
                'family': '微软雅黑,Microsoft Yahei,Arial'
            });
            this.canvas.addShape(this.text);
        },

        registerUpdateRules: function() {
            return kity.Utils.extend(this.callBase(), {
                'updateText': ['text'],
                'updateAnchor': ['at', 'margin', 'rotate'],
                'updateColor': ['color'],
                'updateStyle': ['style']
            });
        },

        getAnimatedParam: function() {
            return [];
        },

        updateText: function(text) {
            this.text.setContent(text);
            this.updateSize();

            // 文本更新需要更新位置
            this.updateAnchor(this.param.at, this.param.margin, this.param.rotate);
            this.trigger('textchanged');
        },

        updateSize: function() {
            this.size = 0;
            this.size = this.getSize();
            this.trigger('sizechanged');
        },

        getSize: function() {
            return this.size || this.callBase();
        },

        updateStyle: function(style) {
            this.text.setStyle(style);
            this.updateSize();
            this.updateAnchor(this.param.at, this.param.margin, this.param.rotate);
        },

        updateAnchor: function(at, margin, rotate) {
            var hh = this.size.height / 2;
            switch (at) {
                case 'left':
                    this.text.setTextAnchor('end').setPosition(margin, hh / 1.5);
                    break;
                case 'right':
                    this.text.setTextAnchor('start').setPosition(margin, hh / 1.5);
                    break;
                case 'up':
                case 'top':
                    this.text.setTextAnchor('middle').setPosition(0, hh - margin);
                    break;
                case 'down':
                case 'bottom':
                    var anchor = 'middle';
                    if (rotate !== 0) anchor = 'end';
                    this.text.setTextAnchor(anchor).setPosition(0, hh + margin);
                    break;
                default:
                    this.text.setTextAnchor('middle').setPosition(0, hh * 0.75);
            }

            if (rotate !== 0) this.text.setRotate(rotate);
        },

        updateColor: function(color) {
            this.text.fill(color);
        }

    });

    var ElementList = kc.ElementList = kity.createClass("ElementList", {
        base: kc.ChartElement,
        constructor: function(param) {
            // param
            this.callBase(kity.Utils.extend({
                list: [],
                fx: true,
                common: {}
            }, param));

            this.elementList = [];
            this.updateClass(this.param.elementClass);
            this.fxTimers = [];
        },

        getElementList: function() {
            return this.elementList;
        },

        registerUpdateRules: function() {
            return kity.Utils.extend(this.callBase(), {
                updateClass: ['elementClass'],
                updateCommon: ['common'],
                updateList: ['list']
            });
        },

        updateCommon: function(common) {
            this.elementList.forEach(function(element) {
                element.update(common);
            });
        },

        updateList: function(list) {
            var me = this;
            var elementList = this.elementList,
                growth = list.length - elementList.length,
                fx = kc.fx && this.param.fx,
                delay = 0,
                delayBase = 300 / list.length,
                fxTimers = this.fxTimers;

            this.adjust(growth);

            while (fxTimers.length) {
                clearTimeout(this.fxTimers.pop());
            }

            var count = elementList.length,
                fill = 0,
                me = this;

            function checkFinish() {
                if (fill == count) {
                    me.trigger('listupdatefinish');
                }
            }
            elementList.forEach(function(element, index) {

                if (fx && ('animate' in element)) {
                    fxTimers.push(setTimeout(function() {
                        element.animate(list[index], me.param.animateDuration || 300).timeline.on('finish', function() {
                            fill++;
                            checkFinish();
                        });
                    }, delay));

                    delay += Math.random() * delayBase;

                } else {

                    fill++;
                    checkFinish();
                    element.update(list[index]);
                }

            });
        },

        updateClass: function(elementClass) {
            if (!elementClass || this.elementClass == elementClass) return;
            this.elementClass = elementClass;
            this.shrink(this.elementList.lenght);
        },

        adjust: function(growth) {
            if (growth > 0) {
                this.grow(growth);
            } else if (growth < 0) {
                this.shrink(-growth);
            }
        },

        grow: function(size) {
            var element;
            while (size--) {
                element = new this.elementClass();
                element.container = this;
                this.canvas.addShape(element.canvas);
                this.elementList.push(element);
                element.update(this.param.common);
                if (this.param.fx) {
                    element.canvas.setOpacity(0).fadeIn(500, 'ease');
                } else {
                    element.canvas.setOpacity(1);
                }
            }
        },

        shrink: function(size) {
            var removed = this.elementList.splice(-size);
            while (removed.length) {
                this.canvas.removeShape(removed.pop().canvas);
            }
        },

        find: function(id) {
            for (var i = 0, ii = this.elementList.length; i < ii; i++) {
                if (this.elementList[i].param.id == id) return this.elementList[i];
            }
        }
    });

    //参数格式
    // {
    //             label: {
    //                 at: 'bottom',
    //                 color: 'black',
    //                 text: null,
    //             },
    //             color: '#62a9dd',
    //             radius: 0,
    //             fxEasing: 'easeOutElastic'
    // }
    var ConnectCircleDot = kc.ConnectCircleDot = kity.createClass("ConnectCircleDot", {

        base: kc.AnimatedChartElement,

        constructor: function(param) {
            this.callBase(kity.Utils.extend({
                label: {
                    at: 'bottom',
                    color: 'black',
                    text: null
                },
                color: '#62a9dd',
                radius: 0,
                fxEasing: 'easeOutElastic'
            }, param));
            this.circle = new kity.Circle();
            var selfparam = this.param;
            this.canvas.addShapes([this.circle]);
            this.addElement('label', new kc.Label());
            var label = this.getElement('label');
            this.on("click", function(e) {
                selfparam.chart.highlightBrand(e);
            });
            var me = this;
            var tooltip = document.createElement('div');
            tooltip.setAttribute('class', 'tooltip');
            this.on("mouseover", function(e) {
                me.hover();
                var container = selfparam.chart.paper.container;
                container.appendChild(tooltip);
                tooltip.innerHTML = '<h1>' + selfparam.label.text + '</h1>';
                if (selfparam.tags && selfparam.tags.length !== 0) {
                    var tags = selfparam.tags;
                    for (var i = 0; i < tags.length; i++) {
                        tooltip.innerHTML += '<p><b style="color:#006dbe">' + tags[i].name + ':&nbsp;</b>' + tags[i].value + '</p>'
                    }
                } else {
                    tooltip.innerHTML += '<p><b style="color:#006dbe">所属类别：</b>' + selfparam.brandclass + '</p>';
                }
                tooltip.style.left = (selfparam.x - selfparam.radius) + 'px';
                tooltip.style.top = (selfparam.y + selfparam.radius) + 'px';
            });
            this.on('mouseout', function(e) {
                me.hover(false);
                var container = selfparam.chart.paper.container;
                try {
                    container.removeChild(tooltip);
                } catch (error) {

                }
            });
        },
        hover: function(ishover) {
            if (this.param.ishighlight) return false;
            var selfparam = this.param;
            var label = this.getElement('label');
            if (ishover === undefined || ishover) {
                this.circle.stroke(new kity.Pen(new kity.Color(this.param.color).dec('l', 10), 2));
                label.canvas.setOpacity(1);
            } else {
                this.circle.stroke(0);
                if (selfparam.radius < 10 && selfparam.mode !== 'circle') {
                    label.canvas.setOpacity(0);
                }
            }
        },
        highlight: function(ishighlight) {
            var label = this.getElement('label');
            var selfparam = this.param;
            if (ishighlight === undefined || ishighlight) {
                selfparam.ishighlight = true;
                this.circle.stroke(new kity.Pen(new kity.Color(this.param.color).dec('l', 10), 2));
                label.canvas.setOpacity(1);
            } else {
                selfparam.ishighlight = false;
                this.circle.stroke(0);
                if (selfparam.radius < 10 && selfparam.mode !== 'circle') {
                    label.canvas.setOpacity(0);
                }
            }
        },
        registerUpdateRules: function() {
            return kity.Utils.extend(this.callBase(), {
                'updateRadius': ['radius'],
                'updateColor': ['color'],
                'updateText': ['text']
            });
        },
        updateText: function(text, position) {
            var label = this.getElement('label');
            label.update({
                text: text
            });
        },

        updateRadius: function(radius) {
            this.circle.setRadius(radius);
        },

        updateColor: function(color) {
            //this.circle.fill( color );
            this.circle.fill(new kity.Color(color));
        },
        getAnimatedParam: function() {
            return ['radius'];
        },
        animate: function(afterAnimated, duration, easing, callback) {
            //return this.update( afterAnimated );
            if (!this.fxEnabled()) {
                return this.update(afterAnimated);
            }

            var canAnimated = this.getAnimatedParam(),
                beforeAnimated = this.param,
                beginParam = {},
                finishParam = {},
                staticParam = {},
                animator;
            canAnimated.push('x');
            canAnimated.push('y');

            for (var p in afterAnimated) {
                if (p in beforeAnimated && ~canAnimated.indexOf(p)) {
                    beginParam[p] = beforeAnimated[p];
                    finishParam[p] = afterAnimated[p];
                } else {
                    staticParam[p] = afterAnimated[p];
                }
            }

            this.update(staticParam);

            animator = new kity.Animator({
                beginValue: beginParam,
                finishValue: finishParam,
                setter: function(target, param) {
                    target.update(param);
                    var finish = true;
                    for (var k in param) {
                        if (param[k] !== finishParam[k]) {
                            finish = false;
                        }
                    }
                    //if ( param.x || param.y ) {
                    var cl = target.param.connectLines;
                    var Cx = param.x || target.x;
                    var Cy = param.y || target.y;
                    for (var i = 0; i < cl.length; i++) {
                        if (cl[i].position === 'start') {
                            cl[i].line.update({
                                x1: Cx,
                                y1: Cy,
                                cx: ((finish && beforeAnimated.mode === 'circle') ? beforeAnimated.cx : Cx),
                                cy: ((finish && beforeAnimated.mode === 'circle') ? beforeAnimated.cy : Cy)
                            });
                        } else {
                            cl[i].line.update({
                                x2: Cx,
                                y2: Cy,
                                cx: ((finish && beforeAnimated.mode === 'circle') ? beforeAnimated.cx : Cx),
                                cy: ((finish && beforeAnimated.mode === 'circle') ? beforeAnimated.cy : Cy)
                            });
                        }
                    }
                    var targetparam = target.param;
                    var label = target.getElement('label');
                    var fontSize = targetparam.originradius * 0.8;
                    //console.log( beforeAnimated.radius );
                    //label.text.setScale( 0.9, 0.8 );
                    if (fontSize < 12) {
                        fontSize = 12;
                    };
                    label.text.setFontSize(fontSize);

                    if (targetparam.mode === 'circle') {
                        label.update({
                            'color': targetparam.color,
                        });
                        label.canvas.setOpacity(1);
                        var curRx = Cx - targetparam.Ox;
                        var curRy = Cy - targetparam.Oy;
                        var curR = Math.sqrt((curRx * curRx) + (curRy * curRy));
                        var cosDelta = curRx / curR;
                        var sinDelta = curRy / curR;
                        var rotate = 180 * targetparam.sDelta / targetparam.total;
                        if (rotate >= 90 && rotate <= 270) {
                            label.canvas.setRotate(rotate + 180);
                            label.text.setTextAnchor('end');
                        } else {
                            label.canvas.setRotate(rotate);
                            label.text.setTextAnchor('left');
                        }
                        label.canvas.setTranslate((targetparam.R + 20) * cosDelta - curRx, (targetparam.R + 20) * sinDelta - curRy);
                    } else {
                        label.text.setTextAnchor('middle');
                        label.canvas.setTranslate(0, 0);
                        label.canvas.setRotate(0);
                        if (afterAnimated.radius < 10) {
                            label.canvas.setOpacity(0);
                        } else {
                            label.canvas.setOpacity(1);
                        }
                    }
                    //}
                }
            });
            if (this.timeline) this.timeline.stop();
            this.timeline = animator.start(this,
                duration || this.param.fxTiming || this.fxTiming || 2000,
                easing || this.param.fxEasing || this.fxEasing || 'ease',
                callback);
            //console.log( this.param );
            return this;
        }
    });

    var AxisLine = kc.AxisLine = kity.createClass("AxisLine", {
        base: kc.AnimatedChartElement,
        constructor: function(param) {
            this.callBase(kity.Utils.extend({
                x1: 0,
                y1: 0,
                x2: 100,
                y2: 0,
                bound: null,
                width: 1,
                color: 'black',
                dash: null
            }, param));
            this.line = new kity.Path();
            this.canvas.addShape(this.line);
        },

        getAnimatedParam: function() {
            return ['x1', 'y1', 'x2', 'y2', 'width'];
        },

        registerUpdateRules: function() {
            return kity.Utils.extend(this.callBase(), {
                draw: ['x1', 'y1', 'x2', 'y2', 'bound', 'max', 'divide'],
                stroke: ['color', 'width', 'dash']
            });
        },

        draw: function(x1, y1, x2, y2, bound, max, divide) {
            var drawer = this.line.getDrawer(),
                s = kc.sharpen;

            if (bound) {
                bound = this.boundTo(x1, y1, x2, y2, bound);
            }
            bound = bound || [
                [x1, y1],
                [x2, y2]
            ];
            drawer.clear();
            drawer.moveTo(s(bound[0][0]), s(bound[0][1]));
            drawer.lineTo(s(bound[1][0]), s(bound[1][1]));
            if (max) {
                //计算最大值的数量级
                var oom = Math.log(max) / Math.log(10);
                var oomV = Math.floor(oom);
                //根据数量级和max的值决定分隔情况
                var base = Math.pow(10, oomV);
                var n = max / base;
                //var part = n / 5;
                // console.log( part );
                if ((n < 5 || n > 6) && base > 1) {
                    base = base / 10;
                    n = n * 10;
                    while (n > 6) {
                        n = n / 2;
                        base = base * 2;
                    }
                }
                //绘制顶端的线段
                var bd = [
                    [x1 - 5, y1],
                    [x1, y1]
                ];
                drawer.moveTo(s(bd[0][0]), s(bd[0][1]));
                drawer.lineTo(s(bd[1][0]), s(bd[1][1]));
                for (var i = 0; i < n; i++) {
                    var y2i = y2 - base * i / max * (y2 - y1);
                    var bd = [
                        [x1 - 5, y2i],
                        [x1, y2i]
                    ];
                    drawer.moveTo(s(bd[0][0]), s(bd[0][1]));
                    drawer.lineTo(s(bd[1][0]), s(bd[1][1]));
                    this.canvas.addShape(new kity.Text((base * i).toLocaleString()).setX(x1 - 10).setY(y2i + 6).setTextAnchor('end').setStyle({
                        'font-size': '12px'
                    }));
                }
            } else {
                var length = y2 - y1;
                var space = length / (divide - 1);
                var length;
                for (var i = 0; i < divide; i++) {
                    if ((i + 1) % 4 === 0) {
                        length = 40;
                    } else {
                        length = 5;
                    }
                    var bd = [
                        [x1 - length, y1 + space * i],
                        [x1, y1 + space * i]
                    ];
                    drawer.moveTo(s(bd[0][0]), s(bd[0][1]));
                    drawer.lineTo(s(bd[1][0]), s(bd[1][1]));
                }
            }
        },

        stroke: function(color, width, dash) {
            var pen = new kity.Pen();
            pen.setWidth(width);
            pen.setColor(color);
            if (dash) {
                pen.setDashArray(dash);
            }
            this.line.stroke(pen);
        },

        boundTo: function(x1, y1, x2, y2, bound) {
            var b = bound,
                bx1 = b.x1,
                by1 = b.y1,
                bx2 = b.x2,
                by2 = b.y2,
                k, kk, bx1y, bx2y, by1x, by2x;

            function inRange(x, a, b) {
                return (a <= x && x <= b) || (a >= x && x >= b);
            }

            if (x1 == x2) {
                return [
                    [x1, b.y1],
                    [x2, b.y2]
                ];
            }
            if (y1 == y2) {
                return [
                    [b.x1, y1],
                    [b.x2, y2]
                ];
            }

            k = (x1 - x2) / (y1 - y2);
            kk = 1 / k;
            bx1y = kk * (bx1 - x1) + y1;
            bx2y = kk * (bx2 - x1) + y1;
            by1x = k * (by1 - y1) + x1;
            by2x = k * (by2 - y1) + x1;

            var inc = [];
            if (inRange(bx1y, by1, by2)) {
                inc.push([bx1, bx1y]);
            }
            if (inRange(bx2y, by1, by2)) {
                inc.push([bx2, bx2y]);
            }
            if (inRange(by1x, bx1, bx2)) {
                inc.push([by1x, by1]);
            }
            if (inRange(by2x, bx1, bx2)) {
                inc.push([by2x, by2]);
            }
            if (inc.length > 1) {
                return inc;
            }
        }
    });

    /**
     * @class Tooltip
     *
     * @param {ChartElement} target [Required]
     *        指定 tooltip 的目标，tooltip 的位置会根据该目标定位
     *
     * @param {ChartElement|String} content [Required]
     *        指定 tooltip 的内容，可以为一个 ChartElement 或者是一个 String
     *
     * @param {String|kity.Color} color
     *        指定 tooltip 文本的颜色
     *
     * @param {String|kity.Color} background
     *        指定 tooltip 的背景颜色，不指定则为透明
     *
     * @param {Number} padding
     *        就是 padding，默认值为 10
     *
     * @param {Number} borderRadius
     *        圆角大小，默认值为 0
     *
     * @param {String} at
     *        指定 tooltip 的渲染位置，允许取值为：
     *        | anchor  | 说明
     *        | 'left'  | tooltip 渲染在目标的左侧
     *        | 'right' | tooltip 渲染在目标的右侧
     *        | 'up'    | tooltip 渲染在目标的上方
     *        | 'down'  | tooltip 渲染在目标的下方
     */

    (function(kc, kity) {

        var Vector = kity.Vector;

        var Tooltip = kc.Tooltip = kity.createClass('Tooltip', {
            base: kc.AnimatedChartElement,

            constructor: function(param) {

                this.callBase(kity.Utils.extend({
                    target: null,
                    content: {
                        color: '#888'
                    },
                    contentClass: kc.Label,

                    background: 'rgba(0,0,0,.8)',

                    at: 'up',
                    padding: [6, 12, 6, 12],
                    borderRadius: 6,
                    anchorSize: 6
                }, param));


                this.canvas.addShape(this.outline = new kity.Path());

                this.addElement('content', this.contentElement = new this.param.contentClass());

                this.contentElement.on('sizechanged textchanged', function() {

                    var p = this.param;
                    this.updateOutline(p.at, p.padding, p.borderRadius, p.anchorSize);

                }.bind(this));
            },

            registerUpdateRules: function() {
                return kity.Utils.extend(this.callBase(), {
                    updateBackground: ['background'],
                    updateOutline: ['at', 'padding', 'borderRadius', 'anchorSize']
                });
            },

            updateBackground: function(bg) {
                this.outline.fill(bg);
            },

            updateOutline: function(at, padding, borderRadius, anchorSize) {
                var contentElement = this.contentElement;
                var contentBox = contentElement.getBoundaryBox();

                if (typeof(padding) == 'number') {
                    padding = [padding, padding, padding, padding];
                }

                var p1 = new Vector(contentBox.x - padding[3], contentBox.y - padding[0]),
                    p2 = new Vector(contentBox.x + contentBox.width + padding[1], p1.y),
                    p3 = new Vector(p2.x, contentBox.y + contentBox.height + padding[2]),
                    p4 = new Vector(p1.x, p3.y);

                p1.rp = [new Vector(p1.x, p1.y + borderRadius), new Vector(p1.x + borderRadius, p1.y)];
                p2.rp = [new Vector(p2.x - borderRadius, p2.y), new Vector(p2.x, p2.y + borderRadius)];
                p3.rp = [new Vector(p3.x, p3.y - borderRadius), new Vector(p3.x - borderRadius, p3.y)];
                p4.rp = [new Vector(p4.x + borderRadius, p4.y), new Vector(p4.x, p4.y - borderRadius)];

                var pseq = {
                    left: [p2, p3, p4, p1],
                    right: [p4, p1, p2, p3],
                    down: [p1, p2, p3, p4],
                    up: [p3, p4, p1, p2]
                }[at];

                var d1 = pseq[0],
                    d2 = pseq[1],
                    d3 = pseq[2],
                    d4 = pseq[3];

                var drawer = this.outline.getDrawer().clear();

                drawer.moveTo(d1.rp[1].x, d1.rp[1].y);

                if (anchorSize > 0 && true) {
                    var side = Vector.fromPoints(d1, d2),
                        halfLength = side.length() / 2;
                    var a1 = d1.add(side.normalize(halfLength - anchorSize)),
                        dt = side.rotate(-90).normalize().add(side.normalize()),
                        a2 = a1.add(dt.multipy(anchorSize)),
                        a3 = a1.add(side.normalize(anchorSize * 2));
                    drawer.lineTo(a1.x, a1.y);
                    drawer.lineTo(a2.x, a2.y);
                    drawer.lineTo(a3.x, a3.y);
                }

                drawer.lineTo(d2.rp[0].x, d2.rp[0].y);
                drawer.carcTo(borderRadius, 0, 1, d2.rp[1].x, d2.rp[1].y);
                drawer.lineTo(d3.rp[0].x, d3.rp[0].y);
                drawer.carcTo(borderRadius, 0, 1, d3.rp[1].x, d3.rp[1].y);
                drawer.lineTo(d4.rp[0].x, d4.rp[0].y);
                drawer.carcTo(borderRadius, 0, 1, d4.rp[1].x, d4.rp[1].y);
                drawer.lineTo(d1.rp[0].x, d1.rp[0].y);
                drawer.carcTo(borderRadius, 0, 1, d1.rp[1].x, d1.rp[1].y);
                drawer.close();

                this.updatePosition();
            },

            updatePosition: function() {
                if (this.param.target) {
                    this.setPosition(this.param.target.getInterestPoint());
                }
            },

            getAnimatedParam: function() {
                return ['x', 'y'];
            },

            show: function() {
                this.updatePosition();
                this.setVisible(true);
            },

            hide: function() {
                this.setVisible(false);
            }
        });

        kity.extendClass(kc.ChartElement, {
            tooltip: function(param) {
                if (this._tooltip) {
                    return this._tooltip.update(param);
                }
                param.target = this;
                var tooltip = new Tooltip(param);
                this.canvas.on('mouseover', tooltip.show.bind(tooltip));
                this.canvas.on('mouseout', tooltip.hide.bind(tooltip));
                this.canvas.container.addShape(tooltip.canvas);
                this._tooltip = tooltip;
            }
        });

    })(kc, kity);

    kc.ChartsConfig = (function() {

        var _configs = {};

        function add(key, val) {
            _configs[key] = val;
        }

        function remove(key) {
            delete _configs[key];
        }

        function init(type) {
            var base = kity.Utils.copy(_configs.base),
                mix;

            if (type in _configs) {
                mix = kity.Utils.deepExtend(base, _configs[type]);
            }

            return mix;
        }

        return {
            add: add,
            init: init
        }

    })();

    kc.ChartsConfig.add('base', {
        color: [
            'rgb(31, 119, 180)',
            'rgb(174, 199, 232)',
            'rgb(255, 127, 14)',
            'rgb(255, 187, 120)',
            'green'
        ],

        finalColor: 'rgb(255, 187, 120)',

        xAxis: {

            ticks: {
                enabled: true,
                dash: null,
                width: 1,
                color: '#808080'
            },

            axis: {
                enabled: true,
                arrow: true
            },

            label: {
                enabled: true,
                rotate: 0
            },

            padding: {
                left: 0,
                right: 20
            },

            margin: {
                left: 80,
                right: 50
            }
        },

        yAxis: {
            categories: [],

            ticks: {
                enabled: true,
                dash: null,
                value: 0,
                width: 1,
                color: '#808080'
            },

            axis: {
                enabled: true,
                arrow: true
            },

            label: {
                enabled: true,
                rotate: 0
            },

            padding: {
                top: 20,
                bottom: 0
            },

            margin: {
                top: 20,
                bottom: 60
            }

        },

        plotOptions: {

            label: {
                enabled: false,
                text: {
                    color: '#333',
                    margin: -15
                }
            }

        },

        interaction: {

            indicatrix: {
                enabled: false,
                color: '#BBB',
                width: 1,
                dash: [4, 2],
            },

            hover: {
                enabled: false,
                circle: {
                    radius: 4,
                    stroke: {
                        width: 2,
                        color: '#FFF'
                    }
                }
            }

        },

        legend: {
            enabled: true,
            level: 'entry'
        },

        enableAnimation: true
    });


    kc.ChartsConfig.add('bar', {

        yAxis: {
            padding: {
                bottom: 30,
                top: 30
            },
            inverted: true,
            min: 0
        },

        plotOptions: {

            bar: {
                width: 25,
                margin: 0
            }

        }

    });


    kc.ChartsConfig.add('column', {

        xAxis: {
            margin: {
                right: 60,
                left: 60
            },

            padding: {
                left: 40,
                right: 40
            }
        },

        yAxis: {
            min: 0,
            padding: {
                top: 0,
                bottom: 0
            }
        },

        plotOptions: {

            column: {
                width: 8,
                margin: 1
            }

        }

    });


    kc.ChartsConfig.add('line', {

        plotOptions: {

            line: {
                width: 2,
                dash: [2],

                dot: {
                    enabled: true,
                    radius: 3
                }

            }

        }

    });


    kc.ChartsConfig.add('area', {

        plotOptions: {

            area: {
                width: 2,
                dash: null,

                label: {
                    enabled: true,
                    radius: 3
                },

                fill: {
                    grandientStopOpacity: 0.5
                }

            }

        }

    });


    kc.ChartsConfig.add('pie', {

        plotOptions: {

            pie: {
                center: {
                    x: 200,
                    y: 200
                },
                stroke: {
                    width: 1,
                    color: '#FFF'
                },
                innerRadius: 40,
                outerRadius: 80,
                incrementRadius: 30
            }

        }

    });

    kc.ChartsConfig.add('scatter', {

        plotOptions: {

            scatter: {
                radius: 5,
                radiusRange: [1, 10]
            }

        }

    });

    var ForceData = kc.ForceData = kity.createClass('ForceData', {
        base: kc.Data,
        format: function() {
            var origin = this.origin;
            var brandSet = {};
            var brandList = [];
            var connectList = [];
            var classList = [];
            var otherList = [];
            //生成List
            for (var key in origin) {
                var d = origin[key];
                //如果集合中还不存在品牌则将品牌加到集合中
                if (d.brand === d.relatedbrand) {
                    //找到和自身class相同的项并按尺寸插入到合适的位置（降序排列）
                    for (var index = 0; index < brandList.length; index++) {
                        if (brandList[index].brandclass === d.brandclass) break;
                    }
                    while (brandList[index] && (brandList[index].brandclass === d.brandclass) && (parseInt(brandList[index].size) > parseInt(d.relation))) {
                        index++;
                    }
                    brandList.splice(index, 0, {
                        brand: d.brand,
                        brandclass: d.brandclass,
                        percent: d.percent,
                        percentall: d.percentall,
                        size: d.relation,
                        tags: d.tags,
                        connects: [] //初始化记录联系的数组
                    });
                    brandSet[d.brand] = brandList[index];
                }
                //记录数据中的相互关联项
                connectList.push({
                    brand: d.brand,
                    relatedbrand: d.relatedbrand,
                    relation: d.relation
                });
                if (classList.indexOf(d.brandclass) === -1) {
                    classList.push(d.brandclass);
                }
            }
            var count = 0;
            for (var i = 0; i < connectList.length; i++) {
                if (connectList[i].brand === connectList[i].relatedbrand || parseInt(connectList[i].relation) === 0) continue;
                count++;
                var source = brandSet[connectList[i].brand];
                var target = brandSet[connectList[i].relatedbrand];
                // if ( !target ) {
                // 	console.log( connectList[ i ].relatedbrand );
                // 	continue;
                // }
                var connects = source.connects;
                connects.push({
                    relatedbrand: target,
                    relation: connectList[i].relation
                });
            }
            return {
                brandSet: brandSet,
                brandList: brandList,
                classList: classList,
                connectCount: count
            };
        }
    });
    var ForceChart = kc.ForceChart = kity.createClass('ForceChart', {
        base: kc.Chart,
        constructor: function(target, param) {
            var me = this;
            this.callBase(target, param);
            //add chart elements
            this.addElement("connects", new kc.ElementList());
            this.addElement("scatter", new kc.ElementList());
            this.setData(new kc.ForceData());
            this.canvas.container.on("click", function(e) {
                if (e.targetShape === me.canvas.container) {
                    me.highlightBrand();
                }
            });
            var scatters = this.getElement("scatter");
            scatters.on('listupdatefinish', function() {
                var mode = me.param.mode;
                var scatterList = me.getElement("scatter").elementList;
                var cntListContainer = me.getElement("connects");

                for (var i = 0; i < scatterList.length; i++) {
                    var disvisConnectLines = scatterList[i].param.disvisConnectLines;
                    for (var j = 0; j < disvisConnectLines.length; j++) {
                        var curC = disvisConnectLines[j];
                        if (curC.position === 'start') {
                            var param = curC.line.param;
                            var cl = curC.line = new kc.Bezier(param);
                            var source = curC.source;
                            var target = curC.target;
                            cntListContainer.addElement('uVcnt' + '0' + i + '0' + j, cl);
                            cl.update({
                                x1: source.x,
                                y1: source.y,
                                x2: target.x,
                                y2: target.y,
                                cx: ((mode === 'circle') ? source.cx : source.x),
                                cy: ((mode === 'circle') ? source.cy : source.y),
                                width: param.originwidth,
                                color: param.color
                            });
                        }
                    }
                }
            });
            this._uvCnt = []; //用于记录暂时不显示的连线
        },
        highlightBrand: function(e) {
            var uvCnt = this._uvCnt;
            var scatterList = this.getElement("scatter").elementList;
            var cntListContainer = this.getElement("connects");
            var cntList = this.getElement("connects").elements;
            var mode = this.param.mode;
            var highlightCircleList = [];
            var highlightConnectList = [];
            uvCnt = this._uvCnt = [];
            //设置全部节点和连线的透明度
            var setAll = function(opaC, opaL) {
                for (var c = 0; c < scatterList.length; c++) {
                    scatterList[c].highlight(false);
                    scatterList[c].canvas.setOpacity(opaC || 0);
                }
                for (var k in cntList) {
                    cntList[k].canvas.setOpacity(opaL || 0);
                    var oWidth = cntList[k].param.originwidth;
                    cntList[k].update({
                        width: oWidth
                    });
                }
            };
            //寻找一个节点的全部相关节点
            var findAllRelatedCircles = function(scatter) {
                var relatedSet = [];
                var connects = scatter.param.connects;
                for (var i = 0; i < connects.length; i++) {
                    var curConnectB = connects[i].relatedbrand.brand;
                    for (j = 0; j < scatterList.length; j++) {
                        var curScatter = scatterList[j];
                        if (curConnectB === curScatter.param.brand) {
                            relatedSet.push(curScatter);
                        }
                    }
                }
                return relatedSet;
            };
            //点中空白区域时直接高亮全部，返回
            if (e === undefined) {
                setAll(1, 1);
                return false;
            }
            //点中单个节点
            if (e instanceof ChartEvent) {
                //点击单个节点
                var circle = e.target;
                highlightCircleList.push(circle);
                var connects = circle.param.connects;
                //判断节点是否在关联的节点集合中
                highlightCircleList = highlightCircleList.concat(findAllRelatedCircles(circle));
                highlightConnectList = highlightConnectList.concat(circle.param.connectLines);
                uvCnt = this._uvCnt = uvCnt.concat(circle.param.disvisConnectLines);
                setAll(0.1);
            } else { //点击图例
                for (var i1 = 0; i1 < scatterList.length; i1++) {
                    var curScatter = scatterList[i1];
                    //所属class
                    if (curScatter.param.brandclass === e) {
                        highlightCircleList.push(curScatter);
                        if (mode !== 'circle') highlightCircleList = highlightCircleList.concat(findAllRelatedCircles(curScatter));
                        highlightConnectList = highlightConnectList.concat(curScatter.param.connectLines);
                        uvCnt = this._uvCnt = uvCnt.concat(curScatter.param.disvisConnectLines);
                    }
                }
                setAll(0.1);
            }
            //统一处理节点和连线的高亮和非高亮
            //disvisConnectLines
            for (var n = 0; n < highlightCircleList.length; n++) {
                highlightCircleList[n].canvas.setOpacity(1);
                highlightCircleList[n].highlight(true);
            }
            for (var m = 0; m < highlightConnectList.length; m++) {
                var l = highlightConnectList[m];
                if (l.position === 'start') {
                    l.line.canvas.setOpacity(1);
                    l.line.update({
                        width: l.line.param.highlightwidth
                    })
                }
            }
            for (var x = 0; x < uvCnt.length; x++) {
                if (uvCnt[x].position === 'start') {
                    var param = uvCnt[x].line.param;
                    var cl = uvCnt[x].line;
                    var source = uvCnt[x].source;
                    var target = uvCnt[x].target;
                    uvCnt[x].line.canvas.setOpacity(1);
                    cl.update({
                        width: param.highlightwidth,
                    });
                }
            }
        },
        renderLegend: function() {
            var data = this.data.format();
            var target = document.getElementById(this.param.legendTarget);
            var colors = this.param.colors;
            var cList = data.classList;
            var items = [];
            for (var i = 0; i < cList.length; i++) {
                var legend = '<li value="' + cList[i] + '"><div class="color-block" style="background:' + colors[i] + '"></div><span class="c-name">' + cList[i] + '</span><span class="c-name-highlight" style="color:' + colors[i] + '">' + cList[i] + '</span></li>';
                items.push(legend);
            }
            target.innerHTML = items.join("");
        },
        adjustScatter: function() {
            var mode = this.param.mode;
            var scatter = this.getElement('scatter');
            var connects = this.getElement('connects');
            var data = this.data.format();
            var param = this.param;
            var colors = (function() {
                var c = {};
                var cList = data.classList;
                for (var i = 0; i < cList.length; i++) {
                    var color = param.colors[i];
                    c[cList[i]] = color;
                }
                return c;
            })();
            var brandSet = data.brandSet;
            var list = data.brandList;
            var paperWidth = this.getWidth();
            var paperHeight = this.getHeight();
            var Ox = paperWidth / 2;
            var Oy = paperHeight / 2;
            var brandTop = data.brandTop;
            //计算全图半径
            var R = 350 || ((Ox < Oy ? Ox : Oy) - 10);
            if (mode === 'circle') {
                R -= 100;
            }
            //初始化圆的尺寸,初始化list数据
            for (var i = 0; i < list.length; i++) {
                list[i].color = colors[list[i].brandclass];
                var circleSize = list[i].size;
                list[i].radius = list[i].originradius = 2 + Math.pow(list[i].size + 1, 27 / list.length);
                list[i].label = {
                    text: list[i].brand,
                    color: 'black'
                };
                list[i].connectLines = [];
                list[i].disvisConnectLines = []; //记录不可见的连线
                list[i].fxEasing = null;
                list[i].mode = mode;
                list[i].Ox = Ox;
                list[i].Oy = Oy;
                list[i].R = R;
                list[i].chart = this;
            }
            //更新连线
            connects.removeElement();
            //connects.canvas.clear();
            var cList = data.classList;
            for (var n = 0; n < list.length; n++) {
                var source = list[n];
                var sourceConnects = source.connects;
                //更新所有的连线
                for (var n1 = 0; n1 < sourceConnects.length; n1++) {
                    var targetInfo = sourceConnects[n1];
                    var target = targetInfo.relatedbrand;
                    var cnt;
                    var cntwidth = Math.log(sourceConnects[n1].relation) / 50;
                    cnt = new kc.Bezier({
                        x1: source.x,
                        y1: source.y,
                        x2: target.x,
                        y2: target.y,
                        cx: target.cx,
                        cy: target.cy,
                        color: target.color,
                        originwidth: cntwidth,
                        width: cntwidth,
                        highlightwidth: (cntwidth * 2 < 1 ? 1 : cntwidth * 2)
                    });
                    //只往画布上添加一部分的连线
                    if (data.connectCount < 300 || cntwidth > data.connectCount / 13000) {
                        connects.addElement(
                            'Vcnt' + '0' + n + '0' + n1, cnt
                        );
                        source.connectLines.push({
                            position: 'start',
                            line: cnt
                        });
                        target.connectLines.push({
                            position: 'end',
                            line: cnt
                        });
                    } else {
                        source.disvisConnectLines.push({
                            source: source,
                            target: target,
                            line: cnt,
                            position: 'start'
                        });
                        target.disvisConnectLines.push({
                            source: source,
                            target: target,
                            line: cnt,
                            position: 'end'
                        });
                    }
                }
            }
            if (mode === 'circle') {
                var total = 0;
                for (var j = 0; j < list.length; j++) {
                    var add = list[j].radius;
                    if (add < 10) add = 10;
                    total += add;
                }
                var sDelta = 0;
                for (var j1 = 0; j1 < list.length; j1++) {
                    if (list[j1].radius > 10)
                        sDelta += list[j1].radius;
                    else
                        sDelta += 10;
                    list[j1].x = R * Math.cos(sDelta * Math.PI / total) + Ox;
                    list[j1].y = R * Math.sin(sDelta * Math.PI / total) + Oy;
                    list[j1].cx = R * 0.2 * Math.cos(sDelta * Math.PI / total) + Ox;
                    list[j1].cy = R * 0.2 * Math.sin(sDelta * Math.PI / total) + Oy;
                    list[j1].sDelta = sDelta;
                    list[j1].total = total;
                    list[j1].mode = 'circle';
                    if (list[j1].radius > 10)
                        sDelta += list[j1].radius;
                    else
                        sDelta += 10;
                    list[j1].radius = list[j1].radius / 3;
                }
            } else {
                var total = 0;
                for (var j3 = 0; j3 < list.length; j3++) {
                    total += list[j3].radius;
                }
                var sDelta = total;
                //将所有的点随机分布在一个圆里
                for (var j4 = 0; j4 < list.length; j4++) {
                    sDelta += list[j4].radius;
                    list[j4].cx = R * 0.2 * Math.cos(sDelta * Math.PI / total) + Ox;
                    list[j4].cy = R * 0.2 * Math.sin(sDelta * Math.PI / total) + Oy;
                    // var P = list[ j4 ].radius * 9;
                    // if ( P > ( R - list[ j4 ].radius ) ) P = R - list[ j4 ].radius;
                    // list[ j4 ].x = P * Math.cos( sDelta * Math.PI / total ) + Ox;
                    // list[ j4 ].y = P * Math.sin( sDelta * Math.PI / total ) + Oy;
                    //循环产生随机数直到没有重叠为止
                    while (true) {
                        var P = Math.random() + list[j4].radius / 70;
                        P = P * R;
                        if (P > (R - list[j4].radius)) P = R - list[j4].radius - Math.random() * R * 0.4;
                        list[j4].x = P * Math.cos(sDelta * Math.PI / total) + Ox;
                        list[j4].y = P * Math.sin(sDelta * Math.PI / total) + Oy;
                        // list[ j4 ].x = Math.random() * paperWidth;
                        // list[ j4 ].y = Math.random() * paperHeight;
                        var noIntersect = true;
                        for (var n = 0; n < j4; n++) {
                            var dx = list[n].x - list[j4].x;
                            var dy = list[n].y - list[j4].y;
                            var d = Math.sqrt(dx * dx + dy * dy);
                            if (d < (list[n].radius + list[j4].radius)) {
                                noIntersect = false;
                                break;
                            }
                        }
                        if (noIntersect) break;
                    }
                    list[j4].sDelta = sDelta;
                    list[j4].total = total;
                    sDelta += list[j4].radius;
                }
                //用力导向算法调整布局
                var setPos = function() {
                    var dt = 1; //为最小单位
                    var k = 1000;
                    for (var i = 1; i < list.length; i++) { //计算下一步的x和y
                        var F = new kity.Vector(0, 0); //记录当前受到的合力
                        var source = list[i];
                        var connects = list[i].connects;
                        for (var j = 0; j < connects.length; j++) {
                            var c = connects[j];
                            var target = c.relatedbrand;
                            var l = source.radius + target.radius + Math.log(c.relation);
                            var dx = target.x - source.x,
                                dy = target.y - source.y;
                            var d = Math.sqrt(dx * dx + dy * dy);
                            var fV = k * (d - l); //分力的值
                            var f = new kity.Vector(dx, dy).normalize(fV);
                            F = F.add(f);
                        }
                        //var k = F.normalize(k);
                        L = F.multipy(1 / k);
                        var targetX = source.x + L.x / 100,
                            targetY = source.y + L.y / 100;
                        //防止重叠
                        var noIntersect = true;
                        for (var n = 0; n < list.length; n++) {
                            if (list[n] === source) continue;
                            var dx = list[n].x - targetX;
                            var dy = list[n].y - targetY;
                            var d = Math.sqrt(dx * dx + dy * dy);
                            if (d < (list[n].radius + source.radius)) {
                                noIntersect = false;
                                break;
                            }
                        }
                        if (noIntersect) {
                            source.x = targetX;
                            source.y = targetY;
                        }
                        //防止溢出边界
                        if (source.x < source.radius) {
                            source.x = source.radius;
                        }
                        if (source.x > (paperWidth - source.radius)) {
                            source.x = paperWidth - source.radius;
                        }
                        if (source.y < source.radius) {
                            source.y = source.radius;
                        }
                        if (source.y > (paperHeight - source.radius)) {
                            source.y = paperHeight - source.radius;
                        }
                    }
                }
                for (var t = 0; t < 10; t++) {
                    setPos();
                }
                // setInterval( function () {
                // 	setPos();
                // 	var List = [].concat( list );
                // 	scatter.update( {
                // 		elementClass: kc.ConnectCircleDot,
                // 		list: List,
                // 		fx: false
                // 	} );
                // } );
            }
            this.param.list = list;
            scatter.update({
                elementClass: kc.ConnectCircleDot,
                list: list,
                animateDuration: 1000
            });
        },
        update: function(args) {
            for (var key in args) {
                this.param[key] = args[key];
            }
            this.adjustScatter();
            this.renderLegend();
        }
    });

    var HorizonData = kc.HorizonData = kity.createClass('HorizonData', {
        base: kc.Data,
        format: function(format) {
            var origin = this.origin;
            if (format === undefined) {
                return origin;
            } else if (format === 'col') {
                //返回每项属性的最大和最小值
                var series = origin.series;
                var result = {};
                var dividecount = 0;
                var ranges = [];
                var labels = [];
                for (var i = 0; i < origin.categories.length; i++) {
                    ranges.push({
                        max: 0,
                        min: 0
                    });
                }
                for (var key in series) {
                    labels.push(key);
                    dividecount++;
                    var s = series[key];
                    for (var j = 0; j < s.length; j++) {
                        var sa = s[j].args;
                        for (var k = 0; k < origin.categories.length; k++) {
                            if (parseFloat(sa[k]) > ranges[k].max) {
                                ranges[k].max = sa[k];
                            } else if (parseFloat(sa[k]) < ranges[k].min) {
                                ranges[k].min = sa[k];
                            }
                        }
                    }
                }
                result.dividecount = dividecount;
                result.ranges = ranges;
                result.labels = labels;
                return result;
            }
        }
    });
    var HorizonChart = kc.HorizonChart = kity.createClass('HorizonChart', {
        base: kc.Chart,
        constructor: function(target, param) {
            this.callBase(target, param);
            this.setData(new kc.HorizonData());
            this.addElement("Lines", new kc.ElementList());
            this.addElement("Axis", new kc.ElementList());
            this.addElement("Cate", new kc.ElementList());
            var tooltips = this.addElement("Tooltips", new kc.ElementList());
            var me = this;
            tooltips.on("listupdatefinish", function(e) {
                var foo = me.toolTipUpdated;
                foo(e);
            });
        },
        toolTipUpdated: function(e) {

        },
        highlightLines: function(args) {
            var data = this.getData().format();
            var key, val;
            for (var k in args) {
                key = k;
                val = args[key];
                break;
            }
            var L = this.getElement('Lines');
            var lines = L.elementList;
            var tooltip = [];
            var tooltips = this.getElement('Tooltips');
            tooltips.except = []; //无需进行亮度处理的部分
            for (var i = 0; i < lines.length; i++) {
                var param = lines[i].param;
                var args = param.args;
                if (param[key] === val) {
                    lines[i].update({
                        width: 3,
                        opacity: 1
                    });
                    lines[i].canvas.bringTop();
                    //更新tooltip
                    var points = param.points;
                    for (var j = 0; j < points.length; j++) {
                        if (j === 0) {
                            tooltip.push({
                                x: points[j][0],
                                y: points[j][1] - 20,
                                content: {
                                    color: 'white',
                                    text: param.contry
                                }
                            });
                            continue;
                        }
                        tooltip.push({
                            x: points[j][0],
                            y: points[j][1] - 20,
                            content: {
                                color: 'white',
                                text: (args[j - 1] || 0)
                            }
                        });
                    }
                } else {
                    lines[i].update({
                        width: 0,
                        opacity: 0
                    });
                }
            }
            tooltips.update({
                elementClass: kc.Tooltip,
                list: tooltip
            });
        },
        showLines: function(args) {
            var lines = this.getElement('Lines').elementList;
            for (var i = 0; i < lines.length; i++) {
                var param = lines[i].param;
                var highlight = true;
                for (var key in args) {
                    if (args[key] && (param[key] !== args[key])) {
                        highlight = false;
                        break;
                    }
                }
                if (!highlight) {
                    lines[i].update({
                        width: 0,
                        opacity: 0
                    });
                } else if (param.width < 3) {
                    lines[i].update({
                        width: 1,
                        opacity: 0.2
                    });
                }
            }
        },
        unhighlightAll: function() {
            var tooltips = this.getElement('Tooltips');
            tooltips.update({
                elementClass: kc.Tooltip,
                list: []
            });
            var lines = this.getElement('Lines').elementList;
            for (var i = 0; i < lines.length; i++) {
                var param = lines[i].param;
                if (param.width === 3) {
                    lines[i].update({
                        width: 1,
                        opacity: 0.2
                    });
                }
            }
        },
        renderChart: function() {
            var colors = this.param.colors;
            var data = this.getData().format();
            var datacol = this.getData().format('col');
            var labels = datacol.labels;
            var categories = data.categories;
            var leftlabels = data.leftlabels;
            var lLength = labels.length - 1;
            var container = this.getPaper().container;
            var _width = container.offsetWidth;
            var _height = container.offsetHeight;
            var padding = this.param.padding;
            var _space = (_width - padding[1] - padding[3]) / categories.length;
            var y_space = (_height - padding[0] - padding[2]) / leftlabels.length;
            var _AxisHeight = _height - padding[0] - padding[2]; //y坐标轴的高度
            var axis = this.getElement('Axis');
            var lines = this.getElement('Lines');
            var Cate = this.getElement('Cate');
            var AxisLines = [];
            var Polylines = [];
            var Cates = [];
            //生成连线和Categories数据
            var series = data.series;
            for (var key in series) {
                var s = series[key];
                // Cates.push({
                //     text: key,
                //     at: 'left',
                //     x: padding[3] - 20,
                //     y: padding[0] + labels.indexOf(key) * _AxisHeight / lLength
                // });
                for (var j = 0; j < s.length; j++) {
                    var item = {
                        points: [
                            [padding[3], padding[0] + labels.indexOf(key) * _AxisHeight / lLength]
                        ],
                        color: colors[parseInt(labels.indexOf(key) / 4)],
                        width: 1,
                        opacity: 0.1,
                        contry: key,
                        position: s[j].position,
                        name: s[j].name,
                        elglishname: s[j].elglishname,
                        args: s[j].args
                    };
                    Polylines.push(item);
                    var args = s[j].args;
                    for (var k = 0; k < args.length; k++) {
                        item.points.push(
                            [padding[3] + _space * (k + 1), padding[0] + (1 - (args[k] || 0) / datacol.ranges[k].max) * _AxisHeight]
                        );
                    }
                }
            };
            //更新x坐标Cate
            for (var x = 0; x < categories.length; x++) {
                Cates.push({
                    text: categories[x],
                    x: padding[3] + _space * (x + 1),
                    y: padding[0] - 20
                });
            }
            //更新y坐标Cate
            for (var y = 0; y < leftlabels.length; y++) {
                Cates.push({
                    text: leftlabels[y],
                    x: padding[3] - 20,
                    y: padding[0] + y_space * (y + 0.4)
                });
            }
            //更新坐标轴数据
            for (var i = 0; i <= data.categories.length; i++) {
                var item = {
                    x1: padding[3] + _space * i,
                    y1: padding[0],
                    x2: padding[3] + _space * i,
                    y2: _height - padding[2]
                };
                if (i !== 0) {
                    item.max = datacol.ranges[i - 1].max;
                } else {
                    item.divide = datacol.dividecount;
                }
                AxisLines.push(item);
            }
            //绘制线
            axis.update({
                elementClass: kc.AxisLine,
                list: AxisLines,
                fx: false
            });
            lines.update({
                elementClass: kc.Polyline,
                list: Polylines,
                fx: false
            });
            Cate.update({
                elementClass: kc.Label,
                list: Cates,
                fx: false
            });
        },
        update: function() {
            this.renderChart();
        }
    });

})(kity, window);